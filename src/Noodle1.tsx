/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { forwardRef, useRef, useState } from "react";
import { MeshDistortMaterial, useGLTF } from "@react-three/drei";
import { GLTF } from "three/examples/jsm/loaders/GLTFLoader";
import useSound from "use-sound";
import { useFrame } from "@react-three/fiber";
import { useSpring, animated } from "@react-spring/three";

type GLTFResult = GLTF & {
  nodes: {
    red_switch: THREE.Mesh;
    round_disc: THREE.Mesh;
    Cube_1: THREE.Mesh;
    Cube_2: THREE.Mesh;
    Cube_3: THREE.Mesh;
    Cube_4: THREE.Mesh;
    Cube_5: THREE.Mesh;
    Cube_6: THREE.Mesh;
    Cube_7: THREE.Mesh;
    Cube_8: THREE.Mesh;
    Cube_9: THREE.Mesh;
  };
  materials: {
    s_Plastic: THREE.MeshPhysicalMaterial;
    s_Chrome: THREE.MeshStandardMaterial;
    Material: THREE.MeshStandardMaterial;
    Chrome: THREE.MeshStandardMaterial;
    Plastic: THREE.MeshStandardMaterial;
    side1: THREE.MeshStandardMaterial;
    side2: THREE.MeshStandardMaterial;
    side3: THREE.MeshStandardMaterial;
    side4: THREE.MeshStandardMaterial;
  };
};

const Model = forwardRef((props: JSX.IntrinsicElements["group"], bloomRef) => {
  const group = useRef<THREE.Group>();
  const redSwitch = useRef<THREE.Mesh>();
  const disc = useRef<THREE.Mesh>();
  const { nodes, materials } = useGLTF("/noodle1_d.gltf") as GLTFResult;

  const [playTap] = useSound("/tapesound2.mp3");

  const [active, setActive] = useState(false);

  // https://docs.pmnd.rs/react-three-fiber/getting-started/using-with-react-spring
  // https://gracious-keller-98ef35.netlify.app/docs/recipes/animating-with-react-spring/
  const { opacity: rotation } = useSpring({
    opacity: active ? Math.PI + Math.PI * 0.05 : Math.PI,
  });
  const { color } = useSpring({
    color: active ? "#f1a208" : "#03090E",
    config: { duration: 2000 },
  });

  const handleTap = () => {
    if (!active) {
      setActive(true);
      setTimeout(() => {
        setActive(false);
      }, 5500);
      playTap();
    }
  };
  // const hingeAxis = new THREE.Vector3(1, 0, 0);

  useFrame(() => {
    active && disc.current.rotateY(Math.PI * 0.1); // TODO: rotate on hinge
  });
  return (
    <group ref={group} {...props} position={[0, 0, 0]} dispose={null}>
      <animated.mesh
        ref={redSwitch}
        onClick={() => handleTap()}
        castShadow
        receiveShadow
        geometry={nodes.red_switch.geometry}
        material={nodes.red_switch.material}
        position={[0.7121842, 1, 0.6018183]}
        rotation-z={Math.PI}
        rotation-x={rotation}
        rotation-y={-2e-7}
        scale={0.4272437}
      />
      <mesh
        ref={disc}
        castShadow
        receiveShadow
        geometry={nodes.round_disc.geometry}
        material={nodes.round_disc.material}
        position={[0.960722, -0.3249993, 0.3517407]}
        rotation={[2.3565738, -5e-7, -Math.PI / 2]}
        scale={[0.3825755, 0.3825755, 0.3825755]}
      >
        <meshStandardMaterial metalness={1} roughness={0} />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube_1.geometry}
        material={materials.Material}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube_2.geometry}
        material={materials.Chrome}
      >
        <meshStandardMaterial metalness={1} roughness={0.1} />
      </mesh>
      <mesh castShadow receiveShadow geometry={nodes.Cube_5.geometry}>
        <meshStandardMaterial metalness={1} roughness={0} />
      </mesh>

      {/* glowy slice */}
      <mesh
        ref={bloomRef}
        castShadow
        receiveShadow
        geometry={nodes.Cube_3.geometry}
        // material={materials.Plastic}
      >
        <animated.meshStandardMaterial color={color} />

        {/* <MeshDistortMaterial
          color="#f25042"
          skinning
          attach="material"
          distort={0.15} // Strength, 0 disables the effect (default=1)
          speed={1} // Speed (default=1)
        /> */}
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube_4.geometry}
        material={nodes.Cube_4.material}
      />

      {/* colored sides of the box */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube_6.geometry}
        // material={materials.side1}
      >
        <meshStandardMaterial metalness={1} color="#272727" roughness={0} />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube_7.geometry}
        // material={materials.side2}
      >
        <meshStandardMaterial metalness={0.3} color="#cccccc" roughness={0} />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube_8.geometry}
        // material={materials.side3}
      >
        <meshStandardMaterial metalness={0.3} color="#cccccc" roughness={0} />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube_9.geometry}
        // material={materials.side4}
      >
        <meshStandardMaterial metalness={0.1} color="#cccccc" roughness={0} />
      </mesh>
    </group>
  );
});
export default Model;
useGLTF.preload("/noodle1_d.gltf");
